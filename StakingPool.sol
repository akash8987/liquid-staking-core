// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./LiquidStakingToken.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract StakingPool is ReentrancyGuard, Ownable {
    LiquidStakingToken public lsToken;
    
    // Tracks the ETH currently held in this contract + ETH on Beacon Chain
    uint256 public totalPooledEther;
    
    address public oracle; // The trusted reporter

    event Deposit(address indexed sender, uint256 amount, uint256 shares);
    event Withdraw(address indexed sender, uint256 amount, uint256 shares);
    event RewardsReported(uint256 newTotalEther);

    constructor(address _token) {
        lsToken = LiquidStakingToken(_token);
        oracle = msg.sender;
    }

    function deposit() external payable nonReentrant {
        require(msg.value > 0, "Zero deposit");

        uint256 shares = getSharesByPooledEth(msg.value);
        
        // Update accounting
        totalPooledEther += msg.value;
        
        // Mint shares to user
        lsToken.mint(msg.sender, shares);
        
        emit Deposit(msg.sender, msg.value, shares);
    }

    function withdraw(uint256 _shares) external nonReentrant {
        require(_shares > 0, "Zero shares");
        
        uint256 ethAmount = getPooledEthByShares(_shares);
        
        // Update accounting
        totalPooledEther -= ethAmount;
        
        // Burn shares and send ETH
        lsToken.burn(msg.sender, _shares);
        (bool sent, ) = msg.sender.call{value: ethAmount}("");
        require(sent, "Failed to send ETH");
        
        emit Withdraw(msg.sender, ethAmount, _shares);
    }

    // Called by Oracle to report rewards generated by validators
    function reportRewards(uint256 _rewards) external {
        require(msg.sender == oracle, "Not oracle");
        
        // Increasing totalPooledEther without minting new shares
        // makes each existing share worth more.
        totalPooledEther += _rewards;
        
        emit RewardsReported(totalPooledEther);
    }

    // --- View Functions (The Math) ---

    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {
        uint256 totalShares = lsToken.totalSupply();
        
        if (totalPooledEther == 0 || totalShares == 0) {
            return _ethAmount; // Initial 1:1 ratio
        }
        
        // Formula: shares = (eth * totalShares) / totalPooledEther
        return (_ethAmount * totalShares) / totalPooledEther;
    }

    function getPooledEthByShares(uint256 _shares) public view returns (uint256) {
        uint256 totalShares = lsToken.totalSupply();
        
        if (totalShares == 0) return 0;
        
        // Formula: eth = (shares * totalPooledEther) / totalShares
        return (_shares * totalPooledEther) / totalShares;
    }
}
